**Tcc分布式事务**

参考博客:https://blog.csdn.net/sinat_29774479/article/details/91038902

**基本原理：**

    TCC 将事务提交分为 Try - Confirm - Cancel3个操作。
    其和两阶段提交有点类似，Try为第一阶段，Confirm - Cancel为第二阶段，是一种应用层面侵入业务的两阶段提交。

**阶段解释:**

    Try: 预留业务资源/数据效验(主要做一些数据校验和业务操作);
    Confirm: 确认执行业务操作，实际提交数据，不做任何业务检查，try成功，confirm必定成功，需保证幂等;
    Cancel: 取消执行业务操作，实际回滚数据，需保证幂等;
    
**优点：**

    其核心在于将业务分为两个操作步骤完成。不依赖 RM 对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。这种分布式事务
    解决方式适用于：并发高的场景因为事务协调器是异步执行的通过Base理论实现事务的最终一致性不像XA协议的2pc需要所有的所有事务参与者都提交
    才能执行成功有一个没有执行完成所有的参与者都处于阻塞状态，提高请求响应时间。
**缺点：**

    对业务代码侵入性高，尤其是需要调用第三方公司的业务代码，不可能让对方改造业务代码来完成tcc。代码编写难度大，
    对业务开发者分布式事务处理能力要求较高。

**常见的TCC分布式解决方案带来的问题:**

   **1.TCC-幂等控制:**
   
        问题：使用TCC时要注意Try - Confirm - Cancel 3个操作的幂等控制,在实际的生产环境：网络原因，
        或者重试操作都有可能导致这几个操作的重复执行,如果没有幂等控制可能造成。
        
        解决方案：使用幂等操作
   **2.TCC-空回滚:**
   
        问题：如下图所示，事务协调器在调用TCC服务的一阶段Try操作时，
        可能会出现因为丢包而导致的网络超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；
        TCC服务在未收到Try请求的情况下收到Cancel请求，这种场景被称为空回滚；TCC服务在实现时应当允许空回滚的执行；
        
        解决方案：
        例如在创建工单的时候，在执行回滚的时候根据工单号查询工单是否存在如果不存在就不需要回滚
        核心思想就是 回滚请求处理时，如果对应的具体业务数据为空，则返回成功
   
   **3.TCC-防悬挂:**
        
        问题：
   
    
    