**1.SEATA是什么:**

    Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。
    Seata 为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。
    
**2.SEATA整体框架:**

     Seata 中有三大模块，分别是 TM、RM 和 TC。
     1.其中 TM 和 RM 是作为 Seata 的客户端与业务系统集成在一起.
     2.TC 作为 Seata 的服务端独立部署。
     
     角色划分：
        TM：事务管理器，开启、 提交、回滚分布式事务。
        
        RM: 资源管理器，注册、 汇报、执⾏资源。
        
        TC :  事务管理器服务功能，存储事务日志、补偿异常事务等、集中管理事务全局锁（全局行锁），seata服务端。
     
     事务执行整体流程：
        1.TM 开启分布式事务（TM 向 TC 注册全局事务记录）；
        
        2.按业务场景，编排数据库、服务等事务内资源（RM 向 TC 汇报资源准备状态 ）；
        
        3.TM 结束分布式事务，事务一阶段结束（TM 通知 TC 提交/回滚分布式事务）；
        
        4.TC 汇总事务信息，决定分布式事务是提交还是回滚；
        
        5.TC 通知所有 RM 提交/回滚 资源，事务二阶段结束；
        
**3.AT模式介绍:**
    
    
    AT 模式是一种无侵入的分布式事务解决方案。在 AT 模式下，用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，
    Seata 框架会自动生成事务的二阶段提交和回滚操作。
    
    整体机制：
        两阶段提交协议的演变：
            一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
            二阶段：提交异步化，非常快速地完成或回滚通过一阶段的回滚日志进行反向补偿。
        详细流程介绍：
            1.在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，
            然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁（生成行锁是为了锁住这条记录防止其人操作当前记录）。
            以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。
            
            2.二阶段如果是提交的话，因为“业务 SQL”在一阶段已经提交至数据库， 
            所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉（解行锁很关键否则会造成死锁），完成数据清理即可。
            
            3.二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。回滚方式便是用“before image”还原业务数据；但在还原前要首先要校验脏写，
            对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，
            如果不一致就说明有脏写，出现脏写就需要转人工处理（如果出现脏写就只能转人工恢复了代码回复会造成问题）。


**4.使用场景:**
    
    分布式事务的业务逻辑中仅仅纯数据库操作，不包含其他中间件事务逻辑。
    
       优势：
            改动及代码侵入最小。由Seata来负责Commit和Rollback的自动化触发或回滚操作。
       劣势：
            1、如果事务中包含缓存存储或发送EQ消息等不适合。
            2、为了保证镜像sql的可靠性，需要用户对sql尽量做简化， 建议做法：将多条SQL语句分解为多个事务中的原子步骤（对应SeataAt模式的分支Branch概念），如果单条SQL语句跨表，也分解成为多个事务中的原子步骤（尽量降低Seata存储镜前SQL结果时的风险）。
            3、多次对DB的操作，以及全局行锁的存在对并发处理性能有影响。
       

                 
            
